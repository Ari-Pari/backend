// Package api provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.5.1 DO NOT EDIT.
package api

import (
	"fmt"
	"net/http"

	"github.com/go-chi/chi/v5"
	"github.com/oapi-codegen/runtime"
)

// Defines values for DanceFullResponseGender.
const (
	DanceFullResponseGenderFemale DanceFullResponseGender = "female"
	DanceFullResponseGenderMale   DanceFullResponseGender = "male"
	DanceFullResponseGenderMulti  DanceFullResponseGender = "multi"
)

// Defines values for DanceSearchRequestGenders.
const (
	DanceSearchRequestGendersFemale DanceSearchRequestGenders = "female"
	DanceSearchRequestGendersMale   DanceSearchRequestGenders = "male"
	DanceSearchRequestGendersMulti  DanceSearchRequestGenders = "multi"
)

// Defines values for DanceSearchRequestSortType.
const (
	ASC  DanceSearchRequestSortType = "ASC"
	DESC DanceSearchRequestSortType = "DESC"
)

// Defines values for DanceSearchRequestSortedBy.
const (
	Alphabet   DanceSearchRequestSortedBy = "alphabet"
	CreatedBy  DanceSearchRequestSortedBy = "createdBy"
	Popularity DanceSearchRequestSortedBy = "popularity"
)

// Defines values for DanceShortResponseGender.
const (
	Female DanceShortResponseGender = "female"
	Male   DanceShortResponseGender = "male"
	Multi  DanceShortResponseGender = "multi"
)

// Defines values for Genre.
const (
	AMULET      Genre = "AMULET"
	COMMUNITY   Genre = "COMMUNITY"
	CULT        Genre = "CULT"
	FESTIVE     Genre = "FESTIVE"
	FUNERAL     Genre = "FUNERAL"
	HUNTING     Genre = "HUNTING"
	LABOR       Genre = "LABOR"
	LYRICAL     Genre = "LYRICAL"
	MATCHMAKERS Genre = "MATCHMAKERS"
	MEMORABLE   Genre = "MEMORABLE"
	MEMORIAL    Genre = "MEMORIAL"
	PILGRIMAGE  Genre = "PILGRIMAGE"
	REVERSE     Genre = "REVERSE"
	RITUAL      Genre = "RITUAL"
	ROAD        Genre = "ROAD"
	WAR         Genre = "WAR"
	WEDDING     Genre = "WEDDING"
)

// Defines values for Handshake.
const (
	BACK         Handshake = "BACK"
	BELT         Handshake = "BELT"
	CROSSED      Handshake = "CROSSED"
	DAGGER       Handshake = "DAGGER"
	FREE         Handshake = "FREE"
	LITTLEFINGER Handshake = "LITTLE_FINGER"
	PALM         Handshake = "PALM"
	SHOULDER     Handshake = "SHOULDER"
	WHIP         Handshake = "WHIP"
)

// DanceFullResponse defines model for DanceFullResponse.
type DanceFullResponse struct {
	Complexity        int                     `json:"complexity"`
	Gender            DanceFullResponseGender `json:"gender"`
	Genres            Genre                   `json:"genres"`
	Handshakes        []Handshake             `json:"handshakes"`
	Id                *int                    `json:"id,omitempty"`
	LessonVideos      *[]VideoResponse        `json:"lessonVideos,omitempty"`
	Name              string                  `json:"name"`
	Paces             []int                   `json:"paces"`
	PerformanceVideos *[]VideoResponse        `json:"performanceVideos,omitempty"`
	PhotoLink         string                  `json:"photo_link"`
	Regions           []RegionResponse        `json:"regions"`
	Songs             []SongResponse          `json:"songs"`
	SourceVideos      *[]VideoResponse        `json:"sourceVideos,omitempty"`
}

// DanceFullResponseGender defines model for DanceFullResponse.Gender.
type DanceFullResponseGender string

// DanceSearchRequest defines model for DanceSearchRequest.
type DanceSearchRequest struct {
	Complexities []int                       `json:"complexities"`
	Genders      []DanceSearchRequestGenders `json:"genders"`
	Genres       Genre                       `json:"genres"`
	Handshakes   []Handshake                 `json:"handshakes"`
	Paces        []int                       `json:"paces"`
	Regions      []int                       `json:"regions"`
	SearchText   string                      `json:"searchText"`
	SortType     DanceSearchRequestSortType  `json:"sortType"`
	SortedBy     DanceSearchRequestSortedBy  `json:"sortedBy"`
}

// DanceSearchRequestGenders defines model for DanceSearchRequest.Genders.
type DanceSearchRequestGenders string

// DanceSearchRequestSortType defines model for DanceSearchRequest.SortType.
type DanceSearchRequestSortType string

// DanceSearchRequestSortedBy defines model for DanceSearchRequest.SortedBy.
type DanceSearchRequestSortedBy string

// DanceSearchResponse defines model for DanceSearchResponse.
type DanceSearchResponse = []DanceShortResponse

// DanceShortResponse defines model for DanceShortResponse.
type DanceShortResponse struct {
	Complexity int                      `json:"complexity"`
	Gender     DanceShortResponseGender `json:"gender"`
	Genres     []Genre                  `json:"genres"`
	Handshakes []Handshake              `json:"handshakes"`
	Id         *int                     `json:"id,omitempty"`
	Name       string                   `json:"name"`
	Paces      []int                    `json:"paces"`
	PhotoLink  string                   `json:"photo_link"`
	Regions    []RegionResponse         `json:"regions"`
}

// DanceShortResponseGender defines model for DanceShortResponse.Gender.
type DanceShortResponseGender string

// EnsembleResponse defines model for EnsembleResponse.
type EnsembleResponse struct {
	Id   int    `json:"id"`
	Link string `json:"link"`
	Name string `json:"name"`
}

// Genre defines model for Genre.
type Genre string

// Handshake defines model for Handshake.
type Handshake string

// RegionListResponse defines model for RegionListResponse.
type RegionListResponse = []RegionResponse

// RegionResponse defines model for RegionResponse.
type RegionResponse struct {
	Id   int    `json:"id"`
	Name string `json:"name"`
}

// SongResponse defines model for SongResponse.
type SongResponse struct {
	Ensembles []EnsembleResponse `json:"ensembles"`
	Id        int                `json:"id"`
	Link      string             `json:"link"`
	Name      string             `json:"name"`
}

// VideoResponse defines model for VideoResponse.
type VideoResponse struct {
	Id   int    `json:"id"`
	Link string `json:"link"`
	Name string `json:"name"`
}

// PostDancesSearchParams defines parameters for PostDancesSearch.
type PostDancesSearchParams struct {
	// Lang Язык
	Lang *string `form:"lang,omitempty" json:"lang,omitempty"`

	// Page Номер страницы
	Page *int `form:"page,omitempty" json:"page,omitempty"`

	// Size Размер страницы
	Size *int `form:"size,omitempty" json:"size,omitempty"`
}

// GetDancesIdParams defines parameters for GetDancesId.
type GetDancesIdParams struct {
	// Lang Язык
	Lang *string `form:"lang,omitempty" json:"lang,omitempty"`
}

// GetRegionsParams defines parameters for GetRegions.
type GetRegionsParams struct {
	// Lang Язык
	Lang *string `form:"lang,omitempty" json:"lang,omitempty"`
}

// PostDancesSearchJSONRequestBody defines body for PostDancesSearch for application/json ContentType.
type PostDancesSearchJSONRequestBody = DanceSearchRequest

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Поиск танцев
	// (POST /dances/search)
	PostDancesSearch(w http.ResponseWriter, r *http.Request, params PostDancesSearchParams)
	// Получить танец
	// (GET /dances/{id})
	GetDancesId(w http.ResponseWriter, r *http.Request, id int, params GetDancesIdParams)
	// Получить список регионов
	// (GET /regions)
	GetRegions(w http.ResponseWriter, r *http.Request, params GetRegionsParams)
}

// Unimplemented server implementation that returns http.StatusNotImplemented for each endpoint.

type Unimplemented struct{}

// Поиск танцев
// (POST /dances/search)
func (_ Unimplemented) PostDancesSearch(w http.ResponseWriter, r *http.Request, params PostDancesSearchParams) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Получить танец
// (GET /dances/{id})
func (_ Unimplemented) GetDancesId(w http.ResponseWriter, r *http.Request, id int, params GetDancesIdParams) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Получить список регионов
// (GET /regions)
func (_ Unimplemented) GetRegions(w http.ResponseWriter, r *http.Request, params GetRegionsParams) {
	w.WriteHeader(http.StatusNotImplemented)
}

// ServerInterfaceWrapper converts contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler            ServerInterface
	HandlerMiddlewares []MiddlewareFunc
	ErrorHandlerFunc   func(w http.ResponseWriter, r *http.Request, err error)
}

type MiddlewareFunc func(http.Handler) http.Handler

// PostDancesSearch operation middleware
func (siw *ServerInterfaceWrapper) PostDancesSearch(w http.ResponseWriter, r *http.Request) {

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params PostDancesSearchParams

	// ------------- Optional query parameter "lang" -------------

	err = runtime.BindQueryParameter("form", true, false, "lang", r.URL.Query(), &params.Lang)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "lang", Err: err})
		return
	}

	// ------------- Optional query parameter "page" -------------

	err = runtime.BindQueryParameter("form", true, false, "page", r.URL.Query(), &params.Page)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "page", Err: err})
		return
	}

	// ------------- Optional query parameter "size" -------------

	err = runtime.BindQueryParameter("form", true, false, "size", r.URL.Query(), &params.Size)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "size", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.PostDancesSearch(w, r, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// GetDancesId operation middleware
func (siw *ServerInterfaceWrapper) GetDancesId(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "id" -------------
	var id int

	err = runtime.BindStyledParameterWithOptions("simple", "id", chi.URLParam(r, "id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "id", Err: err})
		return
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params GetDancesIdParams

	// ------------- Optional query parameter "lang" -------------

	err = runtime.BindQueryParameter("form", true, false, "lang", r.URL.Query(), &params.Lang)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "lang", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetDancesId(w, r, id, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// GetRegions operation middleware
func (siw *ServerInterfaceWrapper) GetRegions(w http.ResponseWriter, r *http.Request) {

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params GetRegionsParams

	// ------------- Optional query parameter "lang" -------------

	err = runtime.BindQueryParameter("form", true, false, "lang", r.URL.Query(), &params.Lang)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "lang", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetRegions(w, r, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

type UnescapedCookieParamError struct {
	ParamName string
	Err       error
}

func (e *UnescapedCookieParamError) Error() string {
	return fmt.Sprintf("error unescaping cookie parameter '%s'", e.ParamName)
}

func (e *UnescapedCookieParamError) Unwrap() error {
	return e.Err
}

type UnmarshalingParamError struct {
	ParamName string
	Err       error
}

func (e *UnmarshalingParamError) Error() string {
	return fmt.Sprintf("Error unmarshaling parameter %s as JSON: %s", e.ParamName, e.Err.Error())
}

func (e *UnmarshalingParamError) Unwrap() error {
	return e.Err
}

type RequiredParamError struct {
	ParamName string
}

func (e *RequiredParamError) Error() string {
	return fmt.Sprintf("Query argument %s is required, but not found", e.ParamName)
}

type RequiredHeaderError struct {
	ParamName string
	Err       error
}

func (e *RequiredHeaderError) Error() string {
	return fmt.Sprintf("Header parameter %s is required, but not found", e.ParamName)
}

func (e *RequiredHeaderError) Unwrap() error {
	return e.Err
}

type InvalidParamFormatError struct {
	ParamName string
	Err       error
}

func (e *InvalidParamFormatError) Error() string {
	return fmt.Sprintf("Invalid format for parameter %s: %s", e.ParamName, e.Err.Error())
}

func (e *InvalidParamFormatError) Unwrap() error {
	return e.Err
}

type TooManyValuesForParamError struct {
	ParamName string
	Count     int
}

func (e *TooManyValuesForParamError) Error() string {
	return fmt.Sprintf("Expected one value for %s, got %d", e.ParamName, e.Count)
}

// Handler creates http.Handler with routing matching OpenAPI spec.
func Handler(si ServerInterface) http.Handler {
	return HandlerWithOptions(si, ChiServerOptions{})
}

type ChiServerOptions struct {
	BaseURL          string
	BaseRouter       chi.Router
	Middlewares      []MiddlewareFunc
	ErrorHandlerFunc func(w http.ResponseWriter, r *http.Request, err error)
}

// HandlerFromMux creates http.Handler with routing matching OpenAPI spec based on the provided mux.
func HandlerFromMux(si ServerInterface, r chi.Router) http.Handler {
	return HandlerWithOptions(si, ChiServerOptions{
		BaseRouter: r,
	})
}

func HandlerFromMuxWithBaseURL(si ServerInterface, r chi.Router, baseURL string) http.Handler {
	return HandlerWithOptions(si, ChiServerOptions{
		BaseURL:    baseURL,
		BaseRouter: r,
	})
}

// HandlerWithOptions creates http.Handler with additional options
func HandlerWithOptions(si ServerInterface, options ChiServerOptions) http.Handler {
	r := options.BaseRouter

	if r == nil {
		r = chi.NewRouter()
	}
	if options.ErrorHandlerFunc == nil {
		options.ErrorHandlerFunc = func(w http.ResponseWriter, r *http.Request, err error) {
			http.Error(w, err.Error(), http.StatusBadRequest)
		}
	}
	wrapper := ServerInterfaceWrapper{
		Handler:            si,
		HandlerMiddlewares: options.Middlewares,
		ErrorHandlerFunc:   options.ErrorHandlerFunc,
	}

	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/dances/search", wrapper.PostDancesSearch)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/dances/{id}", wrapper.GetDancesId)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/regions", wrapper.GetRegions)
	})

	return r
}
