// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: autoupload.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const getDanceRegions = `-- name: GetDanceRegions :many
SELECT dance_id, region_id FROM dance_region
`

type GetDanceRegionsRow struct {
	DanceID  int64 `json:"dance_id"`
	RegionID int64 `json:"region_id"`
}

func (q *Queries) GetDanceRegions(ctx context.Context) ([]GetDanceRegionsRow, error) {
	rows, err := q.db.Query(ctx, getDanceRegions)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetDanceRegionsRow{}
	for rows.Next() {
		var i GetDanceRegionsRow
		if err := rows.Scan(&i.DanceID, &i.RegionID); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getDanceSongs = `-- name: GetDanceSongs :many
SELECT dance_id, song_id FROM dance_song
`

type GetDanceSongsRow struct {
	DanceID int64 `json:"dance_id"`
	SongID  int64 `json:"song_id"`
}

func (q *Queries) GetDanceSongs(ctx context.Context) ([]GetDanceSongsRow, error) {
	rows, err := q.db.Query(ctx, getDanceSongs)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetDanceSongsRow{}
	for rows.Next() {
		var i GetDanceSongsRow
		if err := rows.Scan(&i.DanceID, &i.SongID); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getDanceVideos = `-- name: GetDanceVideos :many
SELECT dance_id, video_id FROM dance_videos
`

type GetDanceVideosRow struct {
	DanceID int64 `json:"dance_id"`
	VideoID int64 `json:"video_id"`
}

func (q *Queries) GetDanceVideos(ctx context.Context) ([]GetDanceVideosRow, error) {
	rows, err := q.db.Query(ctx, getDanceVideos)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetDanceVideosRow{}
	for rows.Next() {
		var i GetDanceVideosRow
		if err := rows.Scan(&i.DanceID, &i.VideoID); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getDances = `-- name: GetDances :many
SELECT id, translation_id, name, complexity, gender,
       paces, popularity, genres, handshakes, deleted_at
FROM dances
`

type GetDancesRow struct {
	ID            int64              `json:"id"`
	TranslationID pgtype.Int8        `json:"translation_id"`
	Name          string             `json:"name"`
	Complexity    pgtype.Int4        `json:"complexity"`
	Gender        string             `json:"gender"`
	Paces         []int32            `json:"paces"`
	Popularity    int32              `json:"popularity"`
	Genres        []string           `json:"genres"`
	Handshakes    []string           `json:"handshakes"`
	DeletedAt     pgtype.Timestamptz `json:"deleted_at"`
}

func (q *Queries) GetDances(ctx context.Context) ([]GetDancesRow, error) {
	rows, err := q.db.Query(ctx, getDances)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetDancesRow{}
	for rows.Next() {
		var i GetDancesRow
		if err := rows.Scan(
			&i.ID,
			&i.TranslationID,
			&i.Name,
			&i.Complexity,
			&i.Gender,
			&i.Paces,
			&i.Popularity,
			&i.Genres,
			&i.Handshakes,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getEnsembles = `-- name: GetEnsembles :many
SELECT id, translation_id, name, link FROM ensembles
`

type GetEnsemblesRow struct {
	ID            int64       `json:"id"`
	TranslationID pgtype.Int8 `json:"translation_id"`
	Name          string      `json:"name"`
	Link          string      `json:"link"`
}

func (q *Queries) GetEnsembles(ctx context.Context) ([]GetEnsemblesRow, error) {
	rows, err := q.db.Query(ctx, getEnsembles)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetEnsemblesRow{}
	for rows.Next() {
		var i GetEnsemblesRow
		if err := rows.Scan(
			&i.ID,
			&i.TranslationID,
			&i.Name,
			&i.Link,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRegions = `-- name: GetRegions :many
SELECT id, translation_id, name FROM regions
`

type GetRegionsRow struct {
	ID            int64       `json:"id"`
	TranslationID pgtype.Int8 `json:"translation_id"`
	Name          string      `json:"name"`
}

func (q *Queries) GetRegions(ctx context.Context) ([]GetRegionsRow, error) {
	rows, err := q.db.Query(ctx, getRegions)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetRegionsRow{}
	for rows.Next() {
		var i GetRegionsRow
		if err := rows.Scan(&i.ID, &i.TranslationID, &i.Name); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSongs = `-- name: GetSongs :many
SELECT id, translation_id, name, file_key FROM songs
`

type GetSongsRow struct {
	ID            int64       `json:"id"`
	TranslationID pgtype.Int8 `json:"translation_id"`
	Name          string      `json:"name"`
	FileKey       string      `json:"file_key"`
}

func (q *Queries) GetSongs(ctx context.Context) ([]GetSongsRow, error) {
	rows, err := q.db.Query(ctx, getSongs)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetSongsRow{}
	for rows.Next() {
		var i GetSongsRow
		if err := rows.Scan(
			&i.ID,
			&i.TranslationID,
			&i.Name,
			&i.FileKey,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTranslations = `-- name: GetTranslations :many
SELECT id, eng_name, ru_name, arm_name FROM translations
`

type GetTranslationsRow struct {
	ID      int64       `json:"id"`
	EngName pgtype.Text `json:"eng_name"`
	RuName  pgtype.Text `json:"ru_name"`
	ArmName pgtype.Text `json:"arm_name"`
}

func (q *Queries) GetTranslations(ctx context.Context) ([]GetTranslationsRow, error) {
	rows, err := q.db.Query(ctx, getTranslations)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetTranslationsRow{}
	for rows.Next() {
		var i GetTranslationsRow
		if err := rows.Scan(
			&i.ID,
			&i.EngName,
			&i.RuName,
			&i.ArmName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getVideos = `-- name: GetVideos :many
SELECT id, link, translation_id, name, type FROM videos
`

type GetVideosRow struct {
	ID            int64       `json:"id"`
	Link          string      `json:"link"`
	TranslationID pgtype.Int8 `json:"translation_id"`
	Name          string      `json:"name"`
	Type          string      `json:"type"`
}

func (q *Queries) GetVideos(ctx context.Context) ([]GetVideosRow, error) {
	rows, err := q.db.Query(ctx, getVideos)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetVideosRow{}
	for rows.Next() {
		var i GetVideosRow
		if err := rows.Scan(
			&i.ID,
			&i.Link,
			&i.TranslationID,
			&i.Name,
			&i.Type,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const insertDance = `-- name: InsertDance :exec
INSERT INTO dances (id, translation_id, name, complexity, gender,
                    paces, popularity, genres, handshakes, deleted_at)
VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10)
`

type InsertDanceParams struct {
	ID            int64              `json:"id"`
	TranslationID pgtype.Int8        `json:"translation_id"`
	Name          string             `json:"name"`
	Complexity    pgtype.Int4        `json:"complexity"`
	Gender        string             `json:"gender"`
	Paces         []int32            `json:"paces"`
	Popularity    int32              `json:"popularity"`
	Genres        []string           `json:"genres"`
	Handshakes    []string           `json:"handshakes"`
	DeletedAt     pgtype.Timestamptz `json:"deleted_at"`
}

func (q *Queries) InsertDance(ctx context.Context, arg InsertDanceParams) error {
	_, err := q.db.Exec(ctx, insertDance,
		arg.ID,
		arg.TranslationID,
		arg.Name,
		arg.Complexity,
		arg.Gender,
		arg.Paces,
		arg.Popularity,
		arg.Genres,
		arg.Handshakes,
		arg.DeletedAt,
	)
	return err
}

const insertDanceRegions = `-- name: InsertDanceRegions :exec
INSERT INTO dance_region (dance_id, region_id)
SELECT unnest($1::bigint[])  as dance_id,
       unnest($2::bigint[]) as region_id ON CONFLICT (dance_id, region_id) DO NOTHING
`

type InsertDanceRegionsParams struct {
	DanceIds  []int64 `json:"dance_ids"`
	RegionIds []int64 `json:"region_ids"`
}

func (q *Queries) InsertDanceRegions(ctx context.Context, arg InsertDanceRegionsParams) error {
	_, err := q.db.Exec(ctx, insertDanceRegions, arg.DanceIds, arg.RegionIds)
	return err
}

const insertDanceSongs = `-- name: InsertDanceSongs :exec
INSERT INTO dance_song (dance_id, song_id)
SELECT unnest($1::bigint[]) as dance_id,
       unnest($2::bigint[])  as song_id ON CONFLICT (dance_id, song_id) DO NOTHING
`

type InsertDanceSongsParams struct {
	DanceIds []int64 `json:"dance_ids"`
	SongIds  []int64 `json:"song_ids"`
}

func (q *Queries) InsertDanceSongs(ctx context.Context, arg InsertDanceSongsParams) error {
	_, err := q.db.Exec(ctx, insertDanceSongs, arg.DanceIds, arg.SongIds)
	return err
}

const insertDanceVideos = `-- name: InsertDanceVideos :exec
INSERT INTO dance_videos (dance_id, video_id)
SELECT unnest($1::bigint[]) as dance_id,
       unnest($2::bigint[]) as video_id ON CONFLICT (dance_id, video_id) DO NOTHING
`

type InsertDanceVideosParams struct {
	DanceIds []int64 `json:"dance_ids"`
	VideoIds []int64 `json:"video_ids"`
}

func (q *Queries) InsertDanceVideos(ctx context.Context, arg InsertDanceVideosParams) error {
	_, err := q.db.Exec(ctx, insertDanceVideos, arg.DanceIds, arg.VideoIds)
	return err
}

const insertEnsembles = `-- name: InsertEnsembles :many
INSERT INTO ensembles (translation_id, name, link)
SELECT unnest($1::bigint[]) as translation_id,
       unnest($2::text[])             as name,
       unnest($3::text[])             as link
    RETURNING id
`

type InsertEnsemblesParams struct {
	TranslationIds []int64  `json:"translation_ids"`
	Names          []string `json:"names"`
	Links          []string `json:"links"`
}

func (q *Queries) InsertEnsembles(ctx context.Context, arg InsertEnsemblesParams) ([]int64, error) {
	rows, err := q.db.Query(ctx, insertEnsembles, arg.TranslationIds, arg.Names, arg.Links)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []int64{}
	for rows.Next() {
		var id int64
		if err := rows.Scan(&id); err != nil {
			return nil, err
		}
		items = append(items, id)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const insertRegions = `-- name: InsertRegions :exec
INSERT INTO regions (id, translation_id, name)
SELECT unnest($1::bigint[])             as id,
       unnest($2::bigint[]) as translation_id,
       unnest($3::text[])             as name
`

type InsertRegionsParams struct {
	Ids            []int64  `json:"ids"`
	TranslationIds []int64  `json:"translation_ids"`
	Names          []string `json:"names"`
}

func (q *Queries) InsertRegions(ctx context.Context, arg InsertRegionsParams) error {
	_, err := q.db.Exec(ctx, insertRegions, arg.Ids, arg.TranslationIds, arg.Names)
	return err
}

const insertSongs = `-- name: InsertSongs :exec
INSERT INTO songs (id, translation_id, name, file_key)
SELECT unnest($1::bigint[])             as id,
       unnest($2::bigint[]) as translation_id,
       unnest($3::text[])             as name,
       unnest($4::text[])         as file_key
`

type InsertSongsParams struct {
	Ids            []int64  `json:"ids"`
	TranslationIds []int64  `json:"translation_ids"`
	Names          []string `json:"names"`
	FileKeys       []string `json:"file_keys"`
}

func (q *Queries) InsertSongs(ctx context.Context, arg InsertSongsParams) error {
	_, err := q.db.Exec(ctx, insertSongs,
		arg.Ids,
		arg.TranslationIds,
		arg.Names,
		arg.FileKeys,
	)
	return err
}

const insertTranslations = `-- name: InsertTranslations :many
INSERT INTO translations (eng_name, ru_name, arm_name)
SELECT unnest($1::text[]) as eng_name,
       unnest($2::text[])  as ru_name,
       unnest($3::text[]) as arm_name
    RETURNING id
`

type InsertTranslationsParams struct {
	EngNames []string `json:"eng_names"`
	RuNames  []string `json:"ru_names"`
	ArmNames []string `json:"arm_names"`
}

func (q *Queries) InsertTranslations(ctx context.Context, arg InsertTranslationsParams) ([]int64, error) {
	rows, err := q.db.Query(ctx, insertTranslations, arg.EngNames, arg.RuNames, arg.ArmNames)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []int64{}
	for rows.Next() {
		var id int64
		if err := rows.Scan(&id); err != nil {
			return nil, err
		}
		items = append(items, id)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const insertVideos = `-- name: InsertVideos :many
INSERT INTO videos (link, translation_id, name, type)
SELECT unnest($1::text[])             as link,
       unnest($2::bigint[]) as translation_id,
       unnest($3::text[])             as name,
       unnest($4::text[])             as type
    RETURNING id
`

type InsertVideosParams struct {
	Links          []string `json:"links"`
	TranslationIds []int64  `json:"translation_ids"`
	Names          []string `json:"names"`
	Types          []string `json:"types"`
}

func (q *Queries) InsertVideos(ctx context.Context, arg InsertVideosParams) ([]int64, error) {
	rows, err := q.db.Query(ctx, insertVideos,
		arg.Links,
		arg.TranslationIds,
		arg.Names,
		arg.Types,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []int64{}
	for rows.Next() {
		var id int64
		if err := rows.Scan(&id); err != nil {
			return nil, err
		}
		items = append(items, id)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const truncateAllTables = `-- name: TruncateAllTables :exec
TRUNCATE TABLE
    dance_region,
    dance_song,
    song_ensemble,
    dance_videos,
    regions,
    ensembles,
    songs,
    dances,
    videos,
    translations
    RESTART IDENTITY CASCADE
`

func (q *Queries) TruncateAllTables(ctx context.Context) error {
	_, err := q.db.Exec(ctx, truncateAllTables)
	return err
}
