// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: dances.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const getDanceByID = `-- name: GetDanceByID :one
SELECT d.id, d.complexity, d.photo_key, d.gender, d.paces, d.genres, d.handshakes,
COALESCE(CASE WHEN $2::text = 'ru' THEN t.ru_name WHEN $2::text = 'en' THEN t.eng_name WHEN $2::text = 'arm' THEN t.arm_name ELSE d.name END, d.name)::text AS name
FROM dances d
LEFT JOIN translations t ON d.translation_id = t.id
WHERE d.id = $1
`

type GetDanceByIDParams struct {
	ID   int64       `json:"id"`
	Lang pgtype.Text `json:"lang"`
}

type GetDanceByIDRow struct {
	ID         int64       `json:"id"`
	Complexity pgtype.Int4 `json:"complexity"`
	PhotoKey   pgtype.Text `json:"photo_key"`
	Gender     string      `json:"gender"`
	Paces      []int32     `json:"paces"`
	Genres     []string    `json:"genres"`
	Handshakes []string    `json:"handshakes"`
	Name       string      `json:"name"`
}

func (q *Queries) GetDanceByID(ctx context.Context, arg GetDanceByIDParams) (GetDanceByIDRow, error) {
	row := q.db.QueryRow(ctx, getDanceByID, arg.ID, arg.Lang)
	var i GetDanceByIDRow
	err := row.Scan(
		&i.ID,
		&i.Complexity,
		&i.PhotoKey,
		&i.Gender,
		&i.Paces,
		&i.Genres,
		&i.Handshakes,
		&i.Name,
	)
	return i, err
}

const getRegionsByDanceID = `-- name: GetRegionsByDanceID :many
SELECT 
    r.id,
    COALESCE(
        CASE 
            WHEN $2::text = 'ru' THEN t.ru_name
            WHEN $2::text = 'en' THEN t.eng_name
            WHEN $2::text = 'arm' THEN t.arm_name
            ELSE r.name
        END, 
        r.name
    )::text AS name
FROM regions r
LEFT JOIN translations t ON r.translation_id = t.id
JOIN dance_region dr ON dr.region_id = r.id
WHERE dr.dance_id = $1
`

type GetRegionsByDanceIDParams struct {
	DanceID int64       `json:"dance_id"`
	Lang    pgtype.Text `json:"lang"`
}

type GetRegionsByDanceIDRow struct {
	ID   int64  `json:"id"`
	Name string `json:"name"`
}

func (q *Queries) GetRegionsByDanceID(ctx context.Context, arg GetRegionsByDanceIDParams) ([]GetRegionsByDanceIDRow, error) {
	rows, err := q.db.Query(ctx, getRegionsByDanceID, arg.DanceID, arg.Lang)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetRegionsByDanceIDRow{}
	for rows.Next() {
		var i GetRegionsByDanceIDRow
		if err := rows.Scan(&i.ID, &i.Name); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSongsByDanceID = `-- name: GetSongsByDanceID :many
SELECT s.id, s.name, s.file_key 
FROM songs s 
JOIN dance_song ds ON ds.song_id = s.id 
WHERE ds.dance_id = $1
`

type GetSongsByDanceIDRow struct {
	ID      int64  `json:"id"`
	Name    string `json:"name"`
	FileKey string `json:"file_key"`
}

func (q *Queries) GetSongsByDanceID(ctx context.Context, danceID int64) ([]GetSongsByDanceIDRow, error) {
	rows, err := q.db.Query(ctx, getSongsByDanceID, danceID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetSongsByDanceIDRow{}
	for rows.Next() {
		var i GetSongsByDanceIDRow
		if err := rows.Scan(&i.ID, &i.Name, &i.FileKey); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getVideosByDanceID = `-- name: GetVideosByDanceID :many
SELECT v.id, v.name, v.link, v.type 
FROM videos v 
JOIN dance_videos dv ON dv.video_id = v.id 
WHERE dv.dance_id = $1
`

type GetVideosByDanceIDRow struct {
	ID   int64  `json:"id"`
	Name string `json:"name"`
	Link string `json:"link"`
	Type string `json:"type"`
}

func (q *Queries) GetVideosByDanceID(ctx context.Context, danceID int64) ([]GetVideosByDanceIDRow, error) {
	rows, err := q.db.Query(ctx, getVideosByDanceID, danceID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetVideosByDanceIDRow{}
	for rows.Next() {
		var i GetVideosByDanceIDRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Link,
			&i.Type,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
